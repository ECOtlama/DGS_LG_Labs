---
title: "Week 6: Spatial Statistics"
author: 
- "Marie-Josee Fortin"
- "Helene Wagner"
date: "`r Sys.Date()`"
show_toc: true
output:
  knitr:::html_vignette:
    toc: yes
    fig_width: 4 
    fig_height: 3.5
vignette: >
  %\VignetteIndexEntry{Week 6: Spatial Statistics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## 1. Overview of Worked Example

### a) Goals 

This worked example shows how to:

- Model spatial relationships among sampling locations with distance lags.
- Model spatial relationships among sampling locations with neighbor topology.
- Test for isolation by distance using genetic data.
- Test for spatial autocorrelation in site-level variables.
- Explore patterns of local spatial autocorrelation.

### b) Data set 

Same data set as in Week 5:

Lamy et al. (2012) sampled the freshwater snail *Drepanotrema depressissimum* in a fragmented landscape of tropical ponds on the Carribean island of Guadeloupe. They used a spatially and temporally stratified sampling design with a total of 25 sites, where 12 sites formed four well-separated clusters of three neighbouring sites to study spatial variability, and 12 sites spread across the island were sampled in multiple years to study temporal variability. For each site and year, 22 - 34 individuals were genotyped at ten microsatellite loci. The species is diploid, hermaphroditic, and outcrossed.  

- **dd.ecogen**: The dataset 'dd.ecogen' with genetic data for 1270 snails from 42 populations is included in package 'LandGenCourse'. To load it, type: data(dd.ecogen). 

- **dd.site**: Population-level data from Tables 2 - 5 of Lamy et al. (2012) are available in dataset 'dd.site' (with 25 variables) in package 'LandGenCourse'. To load it, type: data(dd.site). 

All individuals sampled from the same population have the same spatial coordinates, hence we will do all spatial analysis at the population level. 

### c) Required R libraries

All required packages should have been installed already when you installed 'LandGenCourse'.

```{r message=FALSE, warning=TRUE}
require(LandGenCourse)
#require(EcoGenetics)
#require(vegan)
#require(dplyr)
#require(pwr)
#require(effsize)
#library(sp)
#library(rgdal)
require(ggmap)
```

### d) Import data

Let's import the genetic data (spatial and temporal data sets combined, 42 combinations of site and year) and the site data (see Week 5). Use '?dd.ecogen' and '?dd.site' to check helpfile with data set desription.

The 'ecogen' object 'dd.ecogen' contains individual-level data in the following slots:

- **XY**: Spatial coordinates (lat-long format)
- **G**: Microsatellite loci (columns = loci, rows = individuals)
- **A**: Table of allele frequencies (columns = alleles, rows = individuals)
- **S**: Structure variables (SiteID, SITE, YEAR, Cluster)

```{r}
data(dd.ecogen, package = "LandGenCourse")
data(dd.site, package = "LandGenCourse")
```

### e) Plot sites onto Google Maps 

The function 'as.data.frame' converts the SpatialPointsDataFrame 'dd.site' to a regular data frame that combines the site variables from slot @data with the spatial coordinates ('Longitude', 'Latidude') from slot @coords.

The function 'population_map' from package 'gstudio' provides an easy interface for extracting a Google terrain map from any study area based on lat-lon coordinates. This will store the information we need in object 'map' (no map is printed yet).

```{r}
Data <- as.data.frame(dd.site)
map <- gstudio::population_map(Data, map.source="google", zoom=NA)
```

We use function 'ggmap' from package 'ggmap' to create our map with additive layers. The optional layers are added with "+", using various functions from package 'ggplot2' (see Week 6 video and tutorial).

- **ggmap(map)**: Plots the terrain map from Google Maps defined in object 'map'. You can try out this part of the code on its own. By varying the 'zoom' attribute above (integers between 1 and 21) you can zoom in our out, 'zoom=NA' automatically sets the zoom level to the extent of the data.
- **geom_point()**: Adds point data to the map.
- **aes()**: Defines 'aesthetics', i.e., the location of the points and the symbols to be use. Here we vary symbol size by variable 'NLT' and color by 'He'. 
- **annotate()**: Adds labels to the map. 

```{r fig.height=7, fig.width=7}
#require(ggmap)
    ggmap::ggmap(map) + 
      ggplot2::geom_point(ggplot2::aes(x = Longitude, y = Latitude, color = NLT, 
                                       size = 5), data=Data, na.rm=TRUE) + 
      ggplot2::annotate("text", x=Data$Longitude + 0.013, y=Data$Latitude, label = Data$SITE, size=7, col="red", na.rm=TRUE)
```
Last week we found that the site 'PTC' showed unexplained high differentiation (site-level Fst). Given the map, does this make sense? What about the other unusual site 'DESB'?

### f) Convert spatial coordinates to UTM

Some spatial analysis functions can handle 'lat-lon' coordinates, others can't. Therefore it may be useful to start by re-projecting the SpatialPointsDataFrame 'dd.site' from 'latlon' to UTM coordinates. 

What UTM zone would that be? To find out, we can use a small function 'long2UTM', contributed on Stackoverflow by Josh O'Brian: 
https://stackoverflow.com/questions/9186496/determining-utm-zone-to-convert-from-longitude-latitude)

```{r}
long2UTM <- function(long) {
    (floor((long + 180)/6) %% 60) + 1
}

cat("UTM zone:", "\n")
long2UTM(Data$Longitude[1])
```

Now we can reproject the data to UTM zone 20. We do a spatial transformation with the function 'spTranform' from the 'sp' package. To define the target coordinate reference system (CRS), we use the function 'get_proj4' from package 'tmaptools' (see Week 2).

```{r}
dd.site.UTM <- sp::spTransform(dd.site.xy, tmaptools::get_proj4("utm20"))
dimnames(dd.site.UTM@coords)[[2]] <- c("X", "Y")
Data.spatial.UTM <- as.data.frame(dd.site.UTM)[dd.site.UTM@data$Spatial==TRUE,]
```

## 2. Test for isolation by distance with a Mantel test

```{r}

```

## 3. Model spatial relationships with distance lags

```{r}

```

## 4. Model spatial relationships with neighbor topology

```{r}

```

## 5. Test for spatial autocorrelation in site-level variables

Site-level variables (spatial samples only)
NOTE: play with d2, makes a huge difference! How to choose?

```{r}
XY <- Data.spatial.UTM[,c("X", "Y")]
con <- EcoGenetics::eco.weight(XY, method = "circle", 
                               d1 = 0, d2 = 7000, latlon = FALSE)
con
EcoGenetics::eco.plotWeight(con)
EcoGenetics::eco.plotWeight(con, type = "igraph")

# Response variables:
global <- EcoGenetics::eco.gsa(Z = Data.spatial.UTM[, c("RA", "He", "f", "s", 
              "FST.GESTE")], con = con, method = "I", nsim = 200)
EcoGenetics::eco.plotGlobal(global)
global

#Preditor variables:
global <- EcoGenetics::eco.gsa(Z = Data.spatial.UTM[,  c("Size", "NLT", "C", "D", 
              "V", "Stab")], con = con, method = "I", nsim = 200)
EcoGenetics::eco.plotGlobal(global)
global
```

```{r}
```

## 6. Explore patterns of local spatial autocorrelation

```{r}

```








## OLD



### a) Spatial weights

```{r}
data(dd.ecogen)
dd.ecogen

con <- EcoGenetics::eco.weight(dd.ecogen@XY, latlon=TRUE, method = "circle", d1 = 0, d2 = 10000)
EcoGenetics::eco.plotWeight(con)
EcoGenetics::eco.plotWeight(con, type = "igraph")

corm <- EcoGenetics::eco.cormantel(M = dist(dd.ecogen@A), XY = dd.ecogen@XY,  nsim = 99, size = NULL,
                      latlon=TRUE)
EcoGenetics::eco.plotCorrelog(corm)

global <- EcoGenetics::eco.gsa(Z = dd.ecogen@A, con = con, method = "I", nsim = 200)
EcoGenetics::eco.plotGlobal(global)

#corm <- eco.cormantel(M = dist(dd.ecogen@A), XY = dd.ecogen@XY,  nsim = 99, size = 1000)
#con <- eco.weight(dd.ecogen@XY, method = "circle", d2 = 4)
#global <- eco.gsa(Z = dd.ecogen@A, con = con, method = "I", nsim = 200)
#eco.plotGlobal(global)

```

### b) Population-level analysis

Prepare data

```{r}
data(dd.ecogen)

dd.genind <- EcoGenetics::ecogen2genind(dd.ecogen)
dd.genpop <- adegenet::genind2genpop(dd.genind, pop=dd.genind@strata$SiteID)
dd.genpop
XY.pop <- data.frame(t(sapply(split(dd.ecogen@XY, dd.ecogen@S$SiteID), 
                              function(ls) unlist(unique(ls)))))
XY.pop <- dplyr::left_join(data.frame(SiteID=row.names(dd.genpop@tab)), 
                       data.frame(SiteID=row.names(XY.pop), XY.pop), by="SiteID")
row.names(XY.pop) <- XY.pop$SiteID

data(dd.site)
dd.pop <- dplyr::left_join(XY.pop, dd.site, by="SiteID")
row.names(dd.pop) <- dd.pop$SiteID
XY.pop <- XY.pop[,-1]

makefreq(dd.genpop)[1:5,1:5]       # relative allele frequencies
dd.genpop@tab[1:5,1:5]             # absolute allele frequencies

```

```{r}
con <- EcoGenetics::eco.weight(XY.pop, latlon=TRUE, method = "circle", d1 = 0, d2 = 15000)
EcoGenetics::eco.plotWeight(con)
EcoGenetics::eco.plotWeight(con, type = "igraph")

# get source code:
getAnywhere(eco.weight)

#    if (latlon) {
#        XY <- SoDA::geoXY(XY[, 2], XY[, 1], unit = 1)
#    }
#    distancia <- as.matrix(dist(XY, method = dist.method))

max(dist(SoDA::geoXY(XY.pop[, 2], XY.pop[, 1], unit = 1)))
XY.metric <- SoDA::geoXY(XY.pop[, 2], XY.pop[, 1], unit = 1)

con <- EcoGenetics::eco.weight(XY.pop, method = "circle", d1 = 0, d2 = 15000, latlon = TRUE)
EcoGenetics::eco.plotWeight(con)
EcoGenetics::eco.plotWeight(con, type = "igraph")

```

```{r}
corm <- EcoGenetics::eco.cormantel(M = dist(makefreq(dd.genpop)), XY = XY.pop,  nsim = 99, 
                      size = NULL, latlon=TRUE)
EcoGenetics::eco.plotCorrelog(corm)
```

```{r}
con <- EcoGenetics::eco.weight(XY.pop, method = "circle", d1 = 0, d2 = 15000, 
                               latlon = TRUE)
global <- EcoGenetics::eco.gsa(Z = makefreq(dd.genpop), con = con, method = "I", nsim = 200)
EcoGenetics::eco.plotGlobal(global)
```

Site-level variables (spatial samples only)
```{r}
con <- EcoGenetics::eco.weight(XY.pop[dd.pop$Spatial==TRUE,], method = "circle", 
                               d1 = 0, d2 = 15000, latlon = TRUE)
# Response variables:
global <- EcoGenetics::eco.gsa(Z = dd.pop[dd.pop$Spatial==TRUE, 
                             c("RA", "He", "f", "s", "FST.GESTE")], 
                  con = con, method = "I", nsim = 200)
EcoGenetics::eco.plotGlobal(global)

#Preditor variables:
global <- EcoGenetics::eco.gsa(Z = dd.pop[dd.pop$Spatial==TRUE, 
                             c("Size", "NLT", "C", "D", "V", "Stab")], 
                  con = con, method = "I", nsim = 200)
EcoGenetics::eco.plotGlobal(global)
```


### c) Delanuney
```{r}
require(adegenet)
# Delaunay triangulation
temp <-chooseCN(XY.metric[dd.pop$Spatial==TRUE,], type = 1, result.type = "listw", 
                plot.nb = TRUE)
# Gabriel graph
temp <-adegenet::chooseCN(XY.metric[dd.pop$Spatial==TRUE,], type = 2, result.type = "listw", 
                plot.nb = TRUE)
#plot(temp, coords=XY.metric[dd.pop$Spatial==TRUE,])
con <- EcoGenetics::eco.listw2ew(temp)
EcoGenetics::eco.plotWeight(con)
EcoGenetics::eco.plotWeight(con, type = "igraph")
#eco.plotWeight(con, "network", bounded = TRUE, 
#               group = substr(row.names(XY.metric)[dd.pop$Spatial==TRUE], 1, 3))
# Interactive plot
```

```{r}
# Some examples

## example using Sturges' rule (default)
classlist <- EcoGenetics::eco.lagweight(XY.metric[dd.pop$Spatial==TRUE,])
classlist <- EcoGenetics::eco.lagweight(XY.pop[dd.pop$Spatial==TRUE,], latlon = TRUE)

## example dividing the distance range into 4 classes, using a cutoff distance of 15
# DOES NOT WORK DUE TO EMPTY CLASSES
#classlist <- eco.lagweight(XY.metric[dd.pop$Spatial==TRUE,], nclass = 4, smax = 15)
#classlist <- eco.lagweight(XY.pop[dd.pop$Spatial==TRUE,], nclass = 4, smax = 15, latlon=TRUE)

## example using cutoff distances of 3 and 15, and a distance between consecutive classes of 2
#classlist <- eco.lagweight(XY.metric, int = 5000, smin = 1000, smax = 36000)

## example including 1000 individuals per class
classlist <- EcoGenetics::eco.lagweight(XY.metric, size = 50)

str(classlist)
classlist@BREAKS

```

Compute function over network (e.g. local mean)
```{r}
myMatrix <- dd.pop[dd.pop$Spatial==TRUE, c("RA", "He", "f", "s", "FST.GESTE")]
con <- EcoGenetics::eco.weight(XY = XY.metric[dd.pop$Spatial==TRUE,], method = "knearest", k = 5)
result <- EcoGenetics::eco.slide.con(myMatrix, con, function(x) mean(x, na.rm = TRUE))
```

### Correlograms

NOTE: NA's produced, which precludes meanplot. Why?

```{r}
moran <- EcoGenetics::eco.correlog(Z = makefreq(dd.genpop)[dd.pop$Spatial==TRUE,], 
                      XY = XY.pop[dd.pop$Spatial==TRUE,], latlon=TRUE, 
                      method = "I", smax = NULL, size = NULL)
EcoGenetics::eco.plotCorrelog(moran)
EcoGenetics::eco.plotCorrelog(moran, meanplot = TRUE)
```

Mantel correlogram
```{r}
corm <- EcoGenetics::eco.cormantel(M = dist(makefreq(dd.genpop)[dd.pop$Spatial==TRUE,]), 
                      XY = XY.pop[dd.pop$Spatial==TRUE,], latlon=TRUE,  
                      nsim = 99, size = NULL)
EcoGenetics::eco.plotCorrelog(corm)

# The following is based on individual-level genetic data:
#globaltest <- eco.malecot(eco=eco, method = "global", smax = 4, size = 1000)
#globaltest

#eco.plotCorrelog(globaltest, errorbar = TRUE)
```
Truncated Mantel test:
NOTE: check thres (warning message: "the threshold was set as the maximum distance found in d2 (0.580203)")
```{r}
# We use the weights object “con” created above for truncation and computation of a truncated Mantel test
con <- EcoGenetics::eco.weight(XY.pop[dd.pop$Spatial==TRUE,], method = "circle", 
                               d1 = 0, d2 = 500, latlon = TRUE)
EcoGenetics::eco.mantel(dist(myMatrix$RA), dist(XY.pop[dd.pop$Spatial==TRUE,]), latlon=TRUE, 
           con = con, thres = NULL, nsim = 999)
```

Local SA:
```{r}
# Univariate test
con <- EcoGenetics::eco.weight(XY.pop[dd.pop$Spatial==TRUE,], method = "circle", 
                               d1 = 0, d2 = 5000, latlon = TRUE)
localmoran <- EcoGenetics::eco.lsa(myMatrix$RA, con, method = "I", nsim = 999)   

# "rankplot" graph
EcoGenetics::eco.plotLocal(localmoran, significant = TRUE)
```

Some error messages / warnings:

```{r}
# Multivariable test
con <- EcoGenetics::eco.weight(XY.pop[dd.pop$Spatial==TRUE,], method = "circle", d1 = 0, 
                               d2 = 15000, latlon = TRUE)
multiLocal <- EcoGenetics::eco.lsa(makefreq(dd.genpop)[dd.pop$Spatial==TRUE,], con, method = "I", nsim = 99)

# Hover over the image, and select areas with the mouse to zoom; double click to return to the original scale
EcoGenetics::eco.plotLocal(multiLocal)

con2<- EcoGenetics::eco.weight(XY.pop[dd.pop$Spatial==TRUE,], latlon=TRUE, method = "knearest",  
                  k = 4, self = TRUE) 
getis.A <- EcoGenetics::eco.lsa(makefreq(dd.genpop)[dd.pop$Spatial==TRUE,], con2, 
                   method = "G*", nsim = 99, adjust = "none")
EcoGenetics::eco.plotLocal(getis.A)

```


```{r message=FALSE, warning=TRUE, include=FALSE}
detach("package:gstudio", unload=TRUE)
```
