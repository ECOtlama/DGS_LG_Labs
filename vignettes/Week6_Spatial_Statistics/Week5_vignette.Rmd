---
title: "Week 5: Spatial Statistics"
author: 
- "Helene Wagner"
- "Marie-Josee Fortin"
date: "`r Sys.Date()`"
show_toc: true
output:
  knitr:::html_vignette:
    toc: yes
    fig_width: 4 
    fig_height: 3.5
vignette: >
  %\VignetteIndexEntry{Week 5: Spatial Statistics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## 1. Overview of Worked Example

### a) Goals 

This worked example shows how to:

- Calculate genetic distance at the individual and population levels.
- Test for isolation by distance with a Mantel test.
- Calculate Mantel correlograms with varying distance lags.
- Specify spatial weights and calculate Moran's I.

### b) Data set 

We will further analyze the snail data set from Week 4 (Lamy et al. 2012). 

- **dd.ecogen**: An 'ecogen' object with genetic data (10 diploid microsatellite loci) for 1270 individuals of the freshwater snail *Drepanotrema depressissimum*. Included in package 'LandGenCourse'. To load it, type: data(dd.ecogen)
- **dd.site**: Site-level data. To load it, type: data(dd.site)

### c) Required R libraries

All required packages should have been installed already when you installed 'LandGenCourse'.

```{r message=FALSE, warning=TRUE}
require(adegenet)
require(ade4)
require(LandGenCourse)
require(tibble)
require(EcoGenetics)
require(spdep)
#require(dplyr)
```

## Calculate genetic distances

### a) Import and select data

We will only need one year's data from each site:

- From the sites data, we select the rows (combinations of site and year) with 'Spatial==TRUE'.
- From the genetic data, we select the rows (individuals) with matching 'SiteID' (which is a combination of site and year).

Note: 'dd.site' is a SpatialPointsDataFrame, which is an S4 object. We can't use the usual data manipulation functions (developed for S3 objects) on such an object, unless they have been re-programmed as S4 functions to handle the specific object type. As a work-around, we convert dd.site to a data frame that contains both coordinates and site data, using the function 'cbind' to combine the columns.

```{r}
data(dd.site)
dd.site
Snails.site.df <- cbind(dd.site@coords, dd.site@data) %>% 
  filter(Spatial==TRUE)
as.tibble(Snails.site.df)
```

Next, we import and extract the corresponding genetic data.

```{r}
data(dd.ecogen)
dd.ecogen
```

Note: dd.ecogen is an 'ecogen' object (S4). The 'EcoGenetics' package contains functions for data manipulation similar to what we are used to from S3 objects. For instance, we can use the square brackets for slicing an 'ecogen' object (this would not work for a SpationalPointsDataFrame).

Here, we first define a vector 'a' that is 'TRUE' if the value of 'SiteID' of the genetic data is among the values included in our subset of the site data, 'Snails.site.df'. Then we reduce the 'ecogen' object to those rows (individuals) fulfilling the condition. This reduces the number of individuals from 1270 to 749.

```{r}
a <- is.element(dd.ecogen@S$SiteID, Snails.site.df$SiteID)
Snails.ecogen <- dd.ecogen[a,]
Snails.ecogen
```

### b) Import genetic data into adegenet and gstudio

'EcoGenetics' provides convenient functions for converting genetic data to and from other packages.

Import into 'genind' object (package 'adegenet'): there is a dedicated function, but we need to separately declare the variable that represents the populations and write it into the @pop slot of the 'genind' object. 

```{r}
Snails.genind <- EcoGenetics::ecogen2genind(Snails.ecogen)
Snails.genind@pop <- Snails.ecogen@S$SITE
```

For calculating population-level genetic distances, we aggregate the individual-level data to a 'genpop' object with population-level allele frequencies.

```{r}
Snails.genpop <- adegenet::genind2genpop(Snails.genind)
Snails.genpop
```

The object 'Snails.genpop' has 25 rows, each representing a population.

We will also use some functions from the package 'gstudio', hence we import the individuals-level genetic data into 'gstudio':

```{r}
Snails.gstudio <- EcoGenetics::ecogen2gstudio(Snails.ecogen)
tibble::as.tibble(Snails.gstudio)
```

## 2. Calculate genetic distances

Here we'll calcuate a number of different measures of genetic distance, using functions from several packages. Adding the package name to each distance matrix name helps keeping track of methods used.

Note: Some functions provide an option 'linearized = TRUE' to linearize distances 'd' by calculating 'd/(1-d)'. This should result in more linear relationships when plotted or correlated against geographic distance.Here we don't linearize, we can do so later manually.

### a) Genetic distance among individuals (PopGenReport, adegenet)

```{r}
GD.ind.smouse <- PopGenReport::gd.smouse(Snails.genind, verbose=FALSE)  # GenAlEx
GD.ind.propShared <- adegenet::propShared(Snails.genind)     
```

### b) Genetic distance among local populations (PopGenReport, adegenet, mmod)

```{r}
GD.pop.propShared <- PopGenReport::pairwise.propShared(Snails.genind)
GD.pop.Nei <- adegenet::dist.genpop(Snails.genpop, method=1)   
GD.pop.Edwards <- adegenet::dist.genpop(Snails.genpop, method=2)
GD.pop.Reynolds <- adegenet::dist.genpop(Snails.genpop, method=3)  # Co-ancestry coef
GD.pop.Rogers <- adegenet::dist.genpop(Snails.genpop, method=4)  
GD.pop.Provesti <- adegenet::dist.genpop(Snails.genpop, method=5)

GD.pop.Joost <- mmod::pairwise_D(Snails.genind, linearized = FALSE)
GD.pop.Hedrick <- mmod::pairwise_Gst_Hedrick(Snails.genind, linearized = FALSE)
GD.pop.NeiGst <- mmod::pairwise_Gst_Nei(Snails.genind, linearized = FALSE)
```
 
### c) Pair-wise Fst (hierfstat)

Pair-wise Fst values are calculated at the population level.

```{r}
GD.pop.PairwiseFst.hierfstat <- hierfstat::pairwise.fst(Snails.genind, pop = NULL, 
                                        res.type = c("dist"))
```

### d) More distances with gstudio

```{r}
GD.ind.AMOVA.gstudio <- gstudio::genetic_distance(Snails.gstudio, mode = "AMOVA")
GD.pop.Euclidean.gstudio <-gstudio::genetic_distance(Snails.gstudio, mode = "Euclidean", stratum="SITE")
GD.pop.cGD.gstudio <-gstudio::genetic_distance(Snails.gstudio, mode = "cGD", stratum="SITE")
GD.pop.Nei.gstudio <-gstudio::genetic_distance(Snails.gstudio, mode = "Nei", stratum="SITE")
GD.pop.Dps.gstudio <-gstudio::genetic_distance(Snails.gstudio, mode = "Dps", stratum="SITE")
GD.pop.Jaccard.gstudio <-gstudio::genetic_distance(Snails.gstudio, mode = "Jaccard", stratum="SITE")
```

### e) Assemble (and save) distance matrices

We'll store the genetic distances in two lists:

- GD.ind: individual-level genetic distances
- GD.pop: population-level genetic distances

Note: a few measures return similarities (scaled between 0 and 1) instead of distances. For instance, 'proporition of shared alleles' is 1 if the alleles are identical, and zero of no alleles are shared. We convert these values to distances by subtracting them from 1.

Individual level:

```{r}
GD.ind <- list(Smouse.PopGenReport = GD.ind.smouse,
               propShared.adegenet = as.dist(1 - GD.ind.propShared),
               Amova.gstudio = as.dist(GD.ind.AMOVA.gstudio))
round(cor(sapply(GD.ind, function(ls) as.vector(ls))),2)
```

Population level: 

```{r}
GD.pop <- list(pairwiseFst.hierfstat = GD.pop.PairwiseFst.hierfstat,
               propShared.PopGenReport = 1 - GD.pop.propShared,
               Nei.adegenet = GD.pop.Nei,
               Edwards.adegenet = GD.pop.Edwards,
               Reynolds.adegenet = GD.pop.Reynolds,
               Rogers.adegenet = GD.pop.Rogers,
               Provesti.adegenet = GD.pop.Provesti,
               Joost.mmod = GD.pop.Joost,
               Hedrick.mmod = GD.pop.Hedrick,
               Nei.mmod = GD.pop.NeiGst,
               Euclidean.gstudio = as.dist(GD.pop.Euclidean.gstudio),
               cGD.gstudio = as.dist(GD.pop.cGD.gstudio),
               Nei.gstudio = as.dist(GD.pop.Nei.gstudio),
               Dps.gstudio = as.dist(1 - GD.pop.Dps.gstudio),
               Jaccard.gstudio = as.dist(1 - GD.pop.Jaccard.gstudio))
round(cor(sapply(GD.pop, function(ls) as.vector(ls))),2)
```

Consider the correlations printed above. 

- Correlations are high in general, except for conditional genetic distance (cGD) (see Week 13). 
- There are some duplicate measures (with correlation = 1).

Optional: Use 'save' to save an R object to your file system, and 'load' to read it in again. Note: the default setting is that 'save' will overwrite existing files with the same name.

```{r}
#require(here)
#if(!dir.exists(paste0(here(),"/output"))) dir.create(paste0(here(),"/output"))

#save(GD.ind, file = paste0(here(),"/output/GD.ind.RData"))
#load(paste0(here(),"/output/GD.ind.RData"))

#save(GD.pop, file = paste0(here(),"/output/GD.pop.RData"))
#load(paste0(here(),"/output/GD.pop.RData"))
```



## 4. Test for isolation by distance with a Mantel test

Here, we'll create a population-level Mantel correlogram with the proportion of shared alleles.

To calculate the geographic distances, we need to consider the type of spatial coordinates. Here we have Latitude-Longitude data, and these need to be transformed to calculate distances. The function 'eco.cormantel' has an option 'latlon=TRUE' that takes care of this. To uses this option, the coordinates must be in a matrix or data frame with the longitude in the first column and the latitude in the second. 

The biological hypothesis of isolation-by-distance postulates that genetic distance increases with geographic distance. Hence it makes sense to use a one-sided alternative. Somewhat counter-intutitively, we use 'alternative="less"' to test for positive spatial autocorrelation.


```{r}
corm <- eco.cormantel(M = GD.pop$propShared.PopGenReport, XY = Snails.site.df[,c("Longitude", "Latitude")],  nsim = 199, latlon=TRUE, alternative="less")
corm
```

The table shows:

- Breaks of distance lag 'd': here in meters (default for lag definition: Sturges rule)
- Mean distance 'd.mean': mean distance of pairs in each lag.
- obs: observed value of the statistic (default: "pearson" correlation. Use "spearman" for rank correlation)
- Expected value 'exp': expected if there is no autocorrelation.
- P-value 'p.val': default uses a two-sided permutation test with sequential Holm-Bonferroni adjustement of p-values. 
- Number of pairs 'cardinal': number of unique pairs per lag.

The result 'corm' is an object of class 'eco.correlog' (package: EcoGenetics). We can access the table only by 'corm@OUT', or equivalent: 'ecoslot.OUT(corm)'.

Let's plot the correlogram:

```{r}
eco.plotCorrelog(corm)
```

Statistically significant lags are shown in green (CHECK!), non-significant ones in red.

You can hover over individual points of the correlogram to see the test statistic and mean distance.


## 5. Calculate correlograms with different options

### a) Vary distance class definition

Under IBD, at least the first distance lag should show positive spatial autocorrelation. However, the above test did not show any significant spatial autocorrelation. To what degree does this result depend on the following:

- The distance lag definition?
- The measure of genetic distance?
- Non-linear relationship between genetic and geographic distances?

There are several options of the 'eco.cormantel' function to modify the definition of distance classes:

- 'int': distance interval in the units of XY
- 'smin': minimum class distance in the units of XY
- 'smax': maximum class distance in the units of XY
- 'nclass': number of classes
- 'seqvec': vector with breaks in the unites of XY
- 'size': number of individuals per class
- 'bin': rule for constructing intervals if no other parameters provided (default: Sturge's rule)

The easiest ones to modify are either 'nclass' or 'size'. Here we use 'size' to specify that there should be at least 30 (or 100) pairs in each distance class.

```{r fig.show='hold'}
corm.20 <- eco.cormantel(M = GD.pop$propShared.PopGenReport, XY = Snails.site.df[,c("Longitude", "Latitude")],  nsim = 199, latlon=TRUE, alternative="less", size=20)
ecoslot.OUT(corm.20)

corm.50 <- eco.cormantel(M = GD.pop$propShared.PopGenReport, XY = Snails.site.df[,c("Longitude", "Latitude")],  nsim = 199, latlon=TRUE, alternative="less", size=50)
ecoslot.OUT(corm.50)

eco.plotCorrelog(corm.20)
eco.plotCorrelog(corm.50)
```

We can access the p-value of the first distance class:

```{r}
c(Sturge.pval = ecoslot.OUT(corm)[[1]][1,4],
  size.20.pval = ecoslot.OUT(corm.20)[[1]][1,4],
  size.50.pval = ecoslot.OUT(corm.50)[[1]][1,4])
```

So none of the three distance class definitions (Sturge's rule, size = 20, size = 50) resulted in statistically significant p-values. How did the magnitude change?

```{r}
c(Sturge.obs = ecoslot.OUT(corm)[[1]][1,2],
  size.20.obs = ecoslot.OUT(corm.20)[[1]][1,2],
  size.50.obs = ecoslot.OUT(corm.50)[[1]][1,2])
```

The Mantel correlation in teh first distance lag was strongest for Sturge's rule.

In summary, there was some variation between different lag definitions, but the overall results did not change. 

### b) Checking for non-linear relationship

In the following, we'll use Sturge's rule to define distance classes.

Here we'll use two ways to account for potential non-linearity:

- Linearize by calculating d/(1-d) (linearizing manually)
- Calculate rank correlation (using option 'method="spearman"')

```{r}
D <- GD.pop$propShared.PopGenReport / (1 - GD.pop$propShared.PopGenReport)
corm.lin <- eco.cormantel(M = D, XY = Snails.site.df[,c("Longitude", "Latitude")],  nsim = 99, latlon=TRUE, alternative="less")

corm.rank <- eco.cormantel(M = GD.pop$propShared.PopGenReport, XY = Snails.site.df[,c("Longitude", "Latitude")],  nsim = 199, latlon=TRUE, alternative="less", method="spearman")

c(Sturge.pval = ecoslot.OUT(corm)[[1]][1,4],
  lin.pval = ecoslot.OUT(corm.lin)[[1]][1,4],
  rank.pval = ecoslot.OUT(corm.rank)[[1]][1,4])

c(Sturge.obs = ecoslot.OUT(corm)[[1]][1,2],
  line.obs = ecoslot.OUT(corm.lin)[[1]][1,2],
  rank.obs = ecoslot.OUT(corm.rank)[[1]][1,2])
```

Linearization actually weakened the relationship, whereas the rank correlation provided essentially the same result as the linear("pearson") correlation. Non-linearity can thus not explain the absence of significant positive spatial autocorrelation.

### c) Alternative measures of genetic distances

Which measure of genetic distance would provide the strongest Mantel correlation in the first distance class for this data set? 

Here we will cycle through all genetic distance matrices in 'GD.pop' and calculate a Mantel correlogram with Sturge's rule (not linearized, method="pearson"). This may take a while.

```{r}
corm.GD.pop <- lapply(GD.pop, function(x) eco.cormantel(M = x, XY = Snails.site.df[,c("Longitude", "Latitude")],  nsim = 199, latlon=TRUE, alternative="less"))
```

Next, we extract for each genetic distance matrix the observed value of the Mantel correlation for the first distance class and its p-value.

```{r}
data.frame(obs = sapply(corm.GD.pop, function(x) ecoslot.OUT(x)[[1]][1,2]),
           pval = sapply(corm.GD.pop, function(x) ecoslot.OUT(x)[[1]][1,4]))
```

Compare the p-values: some genetic distance measures resulted in significant spatial autocorrelation (indicating IBD), others not! Generally, those with significant p-values showed stronger Mantel correlation values 'obs' for the first distance class.

## 6.Specify spatial weights and calculate Moran's I

### a) Defining spatial neighbors

The function 'chooseCN' (package: adegenet) provides an interface for choosing a connection network, i.e., for defining spatial neighbors. The underlying functions are defined in package 'spdep' (for defining spatial dependence).

### b) Defining spatial weights


### c) Calculating and testing Moran's I




OMIT THE PART BELOW (MANTEL TEST)?

## 3. Test for isolation by distance with a Mantel test

Need to convert geographic coordinates.

```{r}
xy <- SoDA::geoXY(Snails.site.df$Latitude, Snails.site.df$Longitude)
Snails.site.df <- cbind(xy, Snails.site.df)
```

Now we can calculate geographic distances with the 'dist' function.

```{r}
GeogDist <- dist(Snails.site.df[,1:2])
```

Mantel test, using proportion of shared alleles at the population level:

```{r}
eco.mantel(GD.pop$propShared.PopGenReport, GeogDist, con = con, thres = 4, nsim = 999)
```

Now we can calculate geographic distance with the 'dist' function.

```{r}
Dgeo <- dist(coords.pop[,-1])

```

We'll cycle through all population-level distance matrices. For each one, we carry out a Mantel test, and write the value of the Mantel r statistic, and its p-value, into an object 'Result'.

```{r}
Result <- matrix(NA, length(GD.pop), 2, 
                 dimnames=list(names(GD.pop), c("Mantel.r", "p-value")))
for(i in 1:length(GD.pop))
{
  IBD <- ade4::mantel.randtest(as.dist(GD.pop[[i]]),Dgeo)
  Result[i,] <- c(IBD$obs, IBD$pvalue)
}
Result
```      

The Mantel r statistics range between 0.64 and 0.74, which indicates quite strong spatial structure. All tests were statistically significant at alpha = 0.05, i.e., the null hypothesis of no spatial structure could be rejected no matter which distance measure was used. 

Note that we did not check, or linearize, the shape of the relationships - we'll do a more thorough job in Week 6.




```{r message=FALSE, warning=TRUE, include=FALSE}
LandGenCourse::detachAllPackages()
```
