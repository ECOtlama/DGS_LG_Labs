---
title: "Week 5: Spatial Statistics"
author: 
- "Helene Wagner"
- "Marie-Josee Fortin"
date: "`r Sys.Date()`"
show_toc: true
output:
  knitr:::html_vignette:
    toc: yes
    fig_width: 4 
    fig_height: 3.5
vignette: >
  %\VignetteIndexEntry{Week 5: Spatial Statistics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## 1. Overview of Worked Example

### a) Goals 

This worked example shows how to:

- Calculate genetic distance at the individual and population levels.
- Perform a Mantel test to test for IBD.
- Create Mantel correlograms for the genetic data.
- Calculate and test Moran't I for site-level data.

### b) Data set 

We will further analyze the snail data set from Week 4 (Lamy et al. 2012). 

- **dd.ecogen**: An 'ecogen' object with genetic data (10 diploid microsatellite loci) for 1270 individuals of the freshwater snail *Drepanotrema depressissimum*. Included in package 'LandGenCourse'. To load it, type: data(dd.ecogen)
- **dd.site**: Site-level data. To load it, type: data(dd.site)

### c) Required R libraries

All required packages should have been installed already when you installed 'LandGenCourse'.

```{r message=FALSE, warning=TRUE}
#require(adegenet)
#require(ade4)
require(LandGenCourse)
#require(tibble)
#require(EcoGenetics)
#require(spdep)
require(dplyr)
#require(SoDA)
```

## 2. Data import and manipulatoin

### a) Import and select data

We will only need one year's data from each site:

- From the sites data, we select the rows (combinations of site and year) with 'Spatial==TRUE'.
- From the genetic data, we select the rows (individuals) with matching 'SiteID' (which is a combination of site and year).

Note: 'dd.site' is a SpatialPointsDataFrame, which is an S4 object. We can't use the usual data manipulation functions (developed for S3 objects) on such an object, unless they have been re-programmed as S4 functions to handle the specific object type. As a work-around, we convert dd.site to a data frame that contains both coordinates and site data, using the function 'cbind' to combine the columns.

```{r}
data(dd.site)
dd.site
Snails.site.df <- cbind(dd.site@coords, dd.site@data) %>% 
  dplyr::filter(Spatial==TRUE)
tibble::as.tibble(Snails.site.df)
```

For some analyses, we need to convert geographic coordinates from latitude-longitude format into metric coordinates to facilitate the calcultion of geographic distances. We add the metric coordinates ("x" and "Y") at the beginning of the data frame (first two columns) by binding the columns with the coordinates with the columns of the site data frame. 

```{r}
xy <- SoDA::geoXY(Snails.site.df$Latitude, Snails.site.df$Longitude)
Snails.site.df <- cbind(xy, Snails.site.df)
```

Next, we import and extract the corresponding genetic data.

```{r}
data(dd.ecogen, package="LandGenCourse")
dd.ecogen
```

Note: dd.ecogen is an 'ecogen' object (S4). The 'EcoGenetics' package contains functions for data manipulation similar to what we are used to from S3 objects. For instance, we can use the square brackets for slicing an 'ecogen' object (this would not work for a SpationalPointsDataFrame).

Here, we first define a vector 'a' that is 'TRUE' if the value of 'SiteID' of the genetic data is among the values included in our subset of the site data, 'Snails.site.df'. Then we reduce the 'ecogen' object to those rows (individuals) fulfilling the condition. This reduces the number of individuals from 1270 to 749.

```{r}
a <- is.element(dd.ecogen@S$SiteID, Snails.site.df$SiteID)
Snails.ecogen <- dd.ecogen[a,]
Snails.ecogen
```

### b) Import genetic data into adegenet and gstudio

'EcoGenetics' provides convenient functions for converting genetic data to and from other packages.

Import into 'genind' object (package 'adegenet'): there is a dedicated function, but we need to separately declare the variable that represents the populations and write it into the @pop slot of the 'genind' object. 

```{r}
Snails.genind <- EcoGenetics::ecogen2genind(Snails.ecogen)
Snails.genind@pop <- Snails.ecogen@S$SITE
```

For calculating population-level genetic distances, we aggregate the individual-level data to a 'genpop' object with population-level allele frequencies.

```{r}
Snails.genpop <- adegenet::genind2genpop(Snails.genind)
Snails.genpop
```

The object 'Snails.genpop' has 25 rows, each representing a population.

We will also use some functions from the package 'gstudio', hence we import the individuals-level genetic data into 'gstudio':

```{r}
Snails.gstudio <- EcoGenetics::ecogen2gstudio(Snails.ecogen)
tibble::as.tibble(Snails.gstudio)
```

## 3. Calculate genetic distances

Here we'll calcuate a number of different measures of genetic distance, using functions from several packages. Adding the package name to each distance matrix name helps keeping track of methods used.

Note: Some functions provide an option 'linearized = TRUE' to linearize distances 'd' by calculating 'd/(1-d)'. This should result in more linear relationships when plotted or correlated against geographic distance.Here we don't linearize, we can do so later manually.

### a) Genetic distance among individuals (PopGenReport, adegenet)

```{r}
GD.ind.smouse <- PopGenReport::gd.smouse(Snails.genind, verbose=FALSE)  # GenAlEx
GD.ind.propShared <- adegenet::propShared(Snails.genind)     
```

### b) Genetic distance among local populations (PopGenReport, adegenet, mmod)

```{r}
GD.pop.propShared <- PopGenReport::pairwise.propShared(Snails.genind)
GD.pop.Nei <- adegenet::dist.genpop(Snails.genpop, method=1)   
GD.pop.Edwards <- adegenet::dist.genpop(Snails.genpop, method=2)
GD.pop.Reynolds <- adegenet::dist.genpop(Snails.genpop, method=3)  # Co-ancestry coef
GD.pop.Rogers <- adegenet::dist.genpop(Snails.genpop, method=4)  
GD.pop.Provesti <- adegenet::dist.genpop(Snails.genpop, method=5)

GD.pop.Joost <- mmod::pairwise_D(Snails.genind, linearized = FALSE)
GD.pop.Hedrick <- mmod::pairwise_Gst_Hedrick(Snails.genind, linearized = FALSE)
GD.pop.NeiGst <- mmod::pairwise_Gst_Nei(Snails.genind, linearized = FALSE)
```
 
### c) Pair-wise Fst (hierfstat)

Pair-wise Fst values are calculated at the population level.

```{r}
GD.pop.PairwiseFst.hierfstat <- hierfstat::pairwise.fst(Snails.genind, pop = NULL, 
                                        res.type = c("dist"))
```

### d) More distances with gstudio

```{r}
GD.ind.AMOVA.gstudio <- gstudio::genetic_distance(Snails.gstudio, mode = "AMOVA")
GD.pop.Euclidean.gstudio <-gstudio::genetic_distance(Snails.gstudio, mode = "Euclidean", stratum="SITE")
GD.pop.cGD.gstudio <-gstudio::genetic_distance(Snails.gstudio, mode = "cGD", stratum="SITE")
GD.pop.Nei.gstudio <-gstudio::genetic_distance(Snails.gstudio, mode = "Nei", stratum="SITE")
GD.pop.Dps.gstudio <-gstudio::genetic_distance(Snails.gstudio, mode = "Dps", stratum="SITE")
GD.pop.Jaccard.gstudio <-gstudio::genetic_distance(Snails.gstudio, mode = "Jaccard", stratum="SITE")
```

### e) Assemble (and save) distance matrices

We'll store the genetic distances in two lists:

- GD.ind: individual-level genetic distances
- GD.pop: population-level genetic distances

Note: a few measures return similarities (scaled between 0 and 1) instead of distances. For instance, 'proporition of shared alleles' is 1 if the alleles are identical, and zero of no alleles are shared. We convert these values to distances by subtracting them from 1.

Individual level:

```{r}
GD.ind <- list(Smouse.PopGenReport = GD.ind.smouse,
               propShared.adegenet = as.dist(1 - GD.ind.propShared),
               Amova.gstudio = as.dist(GD.ind.AMOVA.gstudio))
round(cor(sapply(GD.ind, function(ls) as.vector(ls))),2)
```

Population level: 

```{r}
GD.pop <- list(pairwiseFst.hierfstat = GD.pop.PairwiseFst.hierfstat,
               propShared.PopGenReport = 1 - GD.pop.propShared,
               Nei.adegenet = GD.pop.Nei,
               Edwards.adegenet = GD.pop.Edwards,
               Reynolds.adegenet = GD.pop.Reynolds,
               Rogers.adegenet = GD.pop.Rogers,
               Provesti.adegenet = GD.pop.Provesti,
               Joost.mmod = GD.pop.Joost,
               Hedrick.mmod = GD.pop.Hedrick,
               Nei.mmod = GD.pop.NeiGst,
               Euclidean.gstudio = as.dist(GD.pop.Euclidean.gstudio),
               cGD.gstudio = as.dist(GD.pop.cGD.gstudio),
               Nei.gstudio = as.dist(GD.pop.Nei.gstudio),
               Dps.gstudio = as.dist(1 - GD.pop.Dps.gstudio),
               Jaccard.gstudio = as.dist(1 - GD.pop.Jaccard.gstudio))
round(cor(sapply(GD.pop, function(ls) as.vector(ls))),2)
```

Consider the correlations printed above. 

- Correlations are high in general, except for conditional genetic distance (cGD) (see Week 13). 
- There are some duplicate measures (with correlation = 1).

Optional: Use 'save' to save an R object to your file system, and 'load' to read it in again. Note: the default setting is that 'save' will overwrite existing files with the same name.

```{r}
#require(here)
#if(!dir.exists(paste0(here(),"/output"))) dir.create(paste0(here(),"/output"))

#save(GD.ind, file = paste0(here(),"/output/GD.ind.RData"))
#load(paste0(here(),"/output/GD.ind.RData"))

#save(GD.pop, file = paste0(here(),"/output/GD.pop.RData"))
#load(paste0(here(),"/output/GD.pop.RData"))
```

## 4. Perform a Mantel test to test for IBD

First, we can calculate geographic distances with the 'dist' function.

```{r}
Dgeo <- dist(Snails.site.df[,1:2])
```

Then we perform a Mantel test for one population-level measure of genetic distance (here: proportion of shared alleles.

```{r}
IBD <- ade4::mantel.randtest(GD.pop$propShared.PopGenReport,Dgeo)
IBD
attributes(IBD)
```

For this measures of genetic diversity, the Mantel correlation was actually negative! What about the other measures?

Here we use 'lapply' to apply the function 'mantel.rantest' to each genetic distance matrix in GD.pop. Then we use 'sapply' to extract two values for each distance matrix: 'obs' is the Mantel r statistic, and 'pvalue' is the p-value. We can find these names with the function 'attributes' (see above).

```{r}
Mantel.test <- lapply(GD.pop, function(x) ade4::mantel.randtest(x,Dgeo))
data.frame(Mantel.r = sapply(Mantel.test, function(x) x$obs),
           p.value = sapply(Mantel.test, function(x) x$pvalue))
```
The nature of the result did not depend on the measure of genetic diversity used. Does this mean that there is no indication of IBD in the data? Let's look at this in a different way, with a Mantel correlogram.

### b) Visually check linearity


```{r fig.width=8, fig.height=12}
par(mfrow=c(5, 3))
for(i in 1:length(GD.pop))
{
  dens <- MASS::kde2d(Dgeo, GD.pop[[i]], n=300)
  myPal <- colorRampPalette(c("white","blue","gold","orange","red"))
  plot(Dgeo, GD.pop[[i]], pch=20, cex=0.5, axes=FALSE, 
       xlab="Geographic Distance", ylab="Genetic Distance")
  image(dens, col=transp(myPal(300), 0.7), add=TRUE)
  abline(lm(GD.pop[[i]] ~ Dgeo))
  lines(loess.smooth(Dgeo, GD.pop[[i]]), col="red")
  mtext(text=names(GD.pop)[i], side=3, line=1, adj=0)
}
```

## 5. Create Mantel correlogram for genetic data

### a) Create a first Mantel correlogram

Here, we'll create a population-level Mantel correlogram with the proportion of shared alleles.

To calculate the geographic distances, we need to consider the type of spatial coordinates. Here we have Latitude-Longitude data, and these need to be transformed to calculate distances. The function 'eco.cormantel' has an option 'latlon=TRUE' that takes care of this. To uses this option, the coordinates must be in a matrix or data frame with the longitude in the first column and the latitude in the second. 

The biological hypothesis of isolation-by-distance postulates that genetic distance increases with geographic distance. Hence it makes sense to use a one-sided alternative. Somewhat counter-intutitively, we use 'alternative="less"' to test for positive spatial autocorrelation.


```{r}
corm <- EcoGenetics::eco.cormantel(M = GD.pop$propShared.PopGenReport, XY = Snails.site.df[,c("Longitude", "Latitude")],  nsim = 199, latlon=TRUE, alternative="less")
corm
```

The table shows:

- Breaks of distance lag 'd': here in meters (default for lag definition: Sturges rule)
- Mean distance 'd.mean': mean distance of pairs in each lag.
- obs: observed value of the statistic (default: "pearson" correlation. Use "spearman" for rank correlation)
- Expected value 'exp': expected if there is no autocorrelation.
- P-value 'p.val': default uses a two-sided permutation test with sequential Holm-Bonferroni adjustement of p-values. 
- Number of pairs 'cardinal': number of unique pairs per lag.

The result 'corm' is an object of class 'eco.correlog' (package: EcoGenetics). We can access the table only by 'corm@OUT', or equivalent: 'ecoslot.OUT(corm)'.

Let's plot the correlogram:

```{r}
EcoGenetics::eco.plotCorrelog(corm)
```

You can hover over individual points of the correlogram to see the test statistic and mean distance.

### b) Vary distance class definition

Under IBD, at least the first distance lag should show positive spatial autocorrelation. However, the above test did not show any significant spatial autocorrelation. To what degree does this result depend on the following:

- The distance lag definition?
- The measure of genetic distance?
- Non-linear relationship between genetic and geographic distances?

There are several options of the 'eco.cormantel' function to modify the definition of distance classes:

- 'int': distance interval in the units of XY
- 'smin': minimum class distance in the units of XY
- 'smax': maximum class distance in the units of XY
- 'nclass': number of classes
- 'seqvec': vector with breaks in the unites of XY
- 'size': number of individuals per class
- 'bin': rule for constructing intervals if no other parameters provided (default: Sturge's rule)

The easiest ones to modify are either 'nclass' or 'size'. Here we use 'size' to specify that there should be at least 30 (or 100) pairs in each distance class.

```{r fig.show='hold'}
corm.20 <- EcoGenetics::eco.cormantel(M = GD.pop$propShared.PopGenReport, XY = Snails.site.df[,c("Longitude", "Latitude")],  nsim = 199, latlon=TRUE, alternative="less", size=20)
EcoGenetics::ecoslot.OUT(corm.20)

corm.50 <- EcoGenetics::eco.cormantel(M = GD.pop$propShared.PopGenReport, XY = Snails.site.df[,c("Longitude", "Latitude")],  nsim = 199, latlon=TRUE, alternative="less", size=50)
EcoGenetics::ecoslot.OUT(corm.50)

EcoGenetics::eco.plotCorrelog(corm.20)
EcoGenetics::eco.plotCorrelog(corm.50)
```

We can access the p-value of the first distance class:

```{r}
c(Sturge.pval = EcoGenetics::ecoslot.OUT(corm)[[1]][1,4],
  size.20.pval = EcoGenetics::ecoslot.OUT(corm.20)[[1]][1,4],
  size.50.pval = EcoGenetics::ecoslot.OUT(corm.50)[[1]][1,4])
```

So none of the three distance class definitions (Sturge's rule, size = 20, size = 50) resulted in statistically significant p-values. How did the magnitude change?

```{r}
c(Sturge.obs = EcoGenetics::ecoslot.OUT(corm)[[1]][1,2],
  size.20.obs = EcoGenetics::ecoslot.OUT(corm.20)[[1]][1,2],
  size.50.obs = EcoGenetics::ecoslot.OUT(corm.50)[[1]][1,2])
```

The Mantel correlation in the first distance lag was strongest for Sturge's rule.

In summary, there was some variation between different lag definitions, but the overall results did not change. 

### c) Checking for non-linear relationship

In the following, we'll use Sturge's rule to define distance classes.

Here we'll use two ways to account for potential non-linearity:

- Linearize by calculating d/(1-d) (linearizing manually)
- Calculate rank correlation (using option 'method="spearman"')

```{r}
D <- GD.pop$propShared.PopGenReport / (1 - GD.pop$propShared.PopGenReport)
corm.lin <- EcoGenetics::eco.cormantel(M = D, XY = Snails.site.df[,c("Longitude", "Latitude")],  nsim = 99, latlon=TRUE, alternative="less")

corm.rank <- EcoGenetics::eco.cormantel(M = GD.pop$propShared.PopGenReport, XY = Snails.site.df[,c("Longitude", "Latitude")],  nsim = 199, latlon=TRUE, alternative="less", method="spearman")

c(Sturge.pval = EcoGenetics::ecoslot.OUT(corm)[[1]][1,4],
  lin.pval = EcoGenetics::ecoslot.OUT(corm.lin)[[1]][1,4],
  rank.pval = EcoGenetics::ecoslot.OUT(corm.rank)[[1]][1,4])

c(Sturge.obs = EcoGenetics::ecoslot.OUT(corm)[[1]][1,2],
  line.obs = EcoGenetics::ecoslot.OUT(corm.lin)[[1]][1,2],
  rank.obs = EcoGenetics::ecoslot.OUT(corm.rank)[[1]][1,2])
```

Linearization actually weakened the relationship, whereas the rank correlation provided essentially the same result as the linear("pearson") correlation. Non-linearity can thus not explain the absence of significant positive spatial autocorrelation.

### d) Alternative measures of genetic distances

Which measure of genetic distance would provide the strongest Mantel correlation in the first distance class for this data set? 

Here we will cycle through all genetic distance matrices in 'GD.pop' and calculate a Mantel correlogram with Sturge's rule (not linearized, method="pearson"). This may take a while.

```{r}
corm.GD.pop <- lapply(GD.pop, function(x) EcoGenetics::eco.cormantel(M = x, XY = Snails.site.df[,c("Longitude", "Latitude")],  nsim = 199, latlon=TRUE, alternative="less"))
```

Next, we extract for each genetic distance matrix the observed value of the Mantel correlation for the first distance class and its p-value.

```{r}
data.frame(obs = sapply(corm.GD.pop, function(x) EcoGenetics::ecoslot.OUT(x)[[1]][1,2]),
           pval = sapply(corm.GD.pop, function(x) EcoGenetics::ecoslot.OUT(x)[[1]][1,4]))
```

Compare the p-values: some genetic distance measures resulted in significant spatial autocorrelation (indicating IBD), others not! Generally, those with significant p-values showed stronger Mantel correlation values 'obs' for the first distance class.

Let's plot the Mantel correlogram for 'Nei.adegenet'. Statistically significant lags are shown in a different color than non-significant ones.

```{r}
EcoGenetics::eco.plotCorrelog(corm.GD.pop$Nei.adegenet)
```

The statistically significan spatial autocorrelation was limited to the first distance lag. 

## 6.Specify spatial weights and calculate Moran's I

In this part, we'll quantify and test Moran's I for the site-level data used in Week 4 lab (including site-level Fst, genetic diversity, and predictor variables).

Note: Above, we used a distance lag approach from geostatistics, here we use spatial neighbours and weights (neighbor topology). Either approach could be used with either type of data.

For a detailed tutorial on defining spatial neighbors and weights, see: https://cran.r-project.org/web/packages/adespatial/vignettes/tutorial.html#irregular-samplings

### a) Defining spatial neighbors

The function 'chooseCN' (package: adegenet) provides an interface for choosing a connection network, i.e., for defining spatial neighbors. The underlying functions are defined in package 'spdep' (for defining spatial dependences). It can return the following graph types:

- Delaunay triangulation (type 1)
- Gabriel graph (type 2)
- Relative neighbours (type 3)
- Minimum spanning tree (type 4)
- Neighbourhood by distance (type 5)
- K nearests neighbours (type 6)
- Inverse distances (type 7)

Here we use types 1 - 6 to define neighbors in different ways. Then we plot each graph in geographic space. Lines indicate pairs of sites classified as neighbors. 

```{r fig.width=8, fig.height=12, fig.show='hold'}
nb.del <- adegenet::chooseCN(xy = Snails.site.df[,1:2], result.type = "nb", plot.nb = FALSE, type = 1)
nb.gab <- adegenet::chooseCN(xy = Snails.site.df[,1:2], result.type = "nb", plot.nb = FALSE, type = 2)
nb.rel <- adegenet::chooseCN(xy = Snails.site.df[,1:2], result.type = "nb", plot.nb = FALSE, type = 3)
nb.mst <- adegenet::chooseCN(xy = Snails.site.df[,1:2], result.type = "nb", plot.nb = FALSE, type = 4)
nb.nbd <- adegenet::chooseCN(xy = Snails.site.df[,1:2], result.type = "nb", plot.nb = FALSE, type = 5, d1=100, d2=15000)
nb.4nn <- adegenet::chooseCN(xy = Snails.site.df[,1:2], result.type = "nb", plot.nb = FALSE, type = 6, k = 4)

par(mfrow=c(2,3), mai=c(0.1,0.1,0.1, 0.1))
plot(nb.del, coords=Snails.site.df[,1:2]); title(main="Delaunay")
plot(nb.gab, coords=Snails.site.df[,1:2]); title(main="Gabriel")
plot(nb.rel, coords=Snails.site.df[,1:2]); title(main= "Rel. neighbors")
plot(nb.mst, coords=Snails.site.df[,1:2]); title(main= "Min. spanning tree")
plot(nb.nbd, coords=Snails.site.df[,1:2]); title(main = "Neighbor distancer")
plot(nb.4nn, coords=Snails.site.df[,1:2]); title(main = "4 nearest neighbors")
par(mfrow=c(1,1))
```

For spatial statistics, spatial neighbors are used to calculate a local mean. We want each site to have multiple neighbors, but they should be nearby only. Gabriel graph (type = 2) is often a good option, and we'll use it for the rest of this worked example.

### b) Defining spatial weights

By default, 'chooseCN' returns row-standardized weights, so that for each site, the weights of its neighbors sum to 1. This means that a local mean can be calculated as a weighted mean of the other sites (non-neighboring sites have a weight of 0).

With the function 'nb2mat' we can convert the neighbor object to a matrix of spatial weights. Let's look at the first five lines and columns:

```{r}
spdep::nb2mat(nb.gab)[1:5,1:5]
```

Each row contains the weights for the neighbors of one site. We see that the fifth site is a neighbor of the first site and vice versa. However, the weights are not the same. It seems that site one has 4 neighbors, so each has a weight of 0.25, whereas site 5 has three neighbors, each with a weight of 0.33.

### c) Calculating and testing Moran's I

```{r}
spdep::moran.test(Snails.site.df$RA, spdep::nb2listw(nb.gab), alternative="greater")
```

The test statistic is 0.17, and the p-value for a one-sided alternative "greater" (i.e., positive spatial autocorrelation) is 0.0834. The autocorrelation in the variable "RA" was too weak to be statistically significant. 

Let's do this for all response and predictor variables and extract the value of the Moran I statistics (for first neighbors) and its p-value.

```{r}
Snails.moran <- lapply(Snails.site.df[,c(13:16, 18:23, 25)], 
                       function(x) spdep::moran.test(x, spdep::nb2listw(nb.gab), alternative="two.sided"))
round(data.frame(obs = sapply(Snails.moran, function(x) as.vector(x$estimate[1])),  
p.value = sapply(Snails.moran, function(x) x$p.value)),3)
```

The variables vary a lot in their strength of spatial autocorrelation.

```{r message=FALSE, warning=TRUE, include=FALSE}
LandGenCourse::detachAllPackages()
```
