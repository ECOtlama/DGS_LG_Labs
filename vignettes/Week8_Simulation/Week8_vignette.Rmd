---
title: "Week 8: Simulation"
author: "Bernd Gruber, Erin Landguth & Helene Wagner"
date: "`r Sys.Date()`"
show_toc: true
output:
  knitr:::html_vignette:
    toc: yes
    fig_width: 4 
    fig_height: 3.5
vignette: >
  %\VignetteIndexEntry{Week 8: Simulation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
## 1. Overview of Worked Example

### a) Goals 

This worked example shows:

- Simulate a metapopulation on a resistance landscape
- Evaluate the power of a partial Mantel test
- Compare partial Mantel test to 'Sunder'

### b) Data set

We will simulate data using the 'landgenreport' function of the package 'PopGenReport'. See: www.popgenreport.org

### c) Required R libraries

All required packages should have been installed already when you installed 'LandGenCourse'.

```{r message=FALSE, warning=TRUE}
library(LandGenCourse)
library(PopGenReport )   #load the package
library(secr)            #to create a random habitat
library(gdistance)
library(mmod)
library(raster)
```

## 2. Initialize a landscape

### a) Create a random landscape 

We will use the 'randomHabitat' function from the 'secr' package, but you can use mutiple different ways. E.g. simply load a png file or any other file format using the 'raster' function from package 'raster' (?raster::raster, see the examples in there).

```{r }
nx=50
ny=50
set.seed(555) #(to make sure we have the same example running)
tempmask<-secr::make.mask(nx=nx,ny=ny,spacing=1)
r <- secr::raster(randomHabitat(tempmask, p = 0.5, A = 0.5))
#set non-habitat to friction values of 10
values(r)[is.na(values(r))==T]<-10
plot(r)
```

### b) Add populations to the landscape (using minimal distance)

We create a function that allows us to set up 'n' subpopulations in the habitat only (non green areas). The subpopulations should be at least 'mindist' units apart.

```{r, echo=TRUE}
createpops <- function(n, mindist, landscape, plot=TRUE)
{  
  minx <- raster::extent(landscape)@xmin #get the min and max  coordinates
  miny <- raster::extent(landscape)@ymin #coordinates of the landscape
  maxx <- raster::extent(landscape)@xmax
  maxy <- raster::extent(landscape)@ymax

  cc<- 1
  coords <- data.frame(lx=NA, ly=NA)
  while (cc<= n )  #repeat until you have found n locations
  {
    draw=FALSE
    while (draw==FALSE)
    {
      x <- runif(1,minx,maxx)
      y <- runif(1,miny,maxy)
      if (landscape[cellFromXY(landscape,c(x,y) )]==1)  draw=TRUE 
      #check if in the habitat
    }

  coords[cc,] <- c(x,y)

  if (nrow(coords)>1) d <- min(dist(coords)) else d <- mindist+1 

  if (d > mindist) cc <- cc+1  
  #take the location only if distance is larger than mindist
  }
  if (plot==TRUE) 
  {
  plot(landscape)  
  points(coords, pch=16)
  }
  return( as.matrix( coords))
}

#test the function above.....
createpops(n=8, mindist = 3, landscape = r, plot = TRUE)
```

### c) Initialise a metapopulation 

We use 'init.popgensim' to initialise a metapopulation based on the locations we created earlier. To do this we need to initialise a number of parameters (the locations of the subpopulations, the number of individuals per subpopulation, the number of loci and alleles per loci. For a full list check '?init.popgensim').

To store all the parameters we create a list called para where we store all of them

## 3. Define simulation parameters

### a) Define your metapopulation

Define metapopulation: 

```{r}
para<- list()
#Define populations (dynamics)
para$n.pops=8
para$n.ind=100

para$sex.ratio <- 0.5
#age distribution....

para$n.cov <- 3 
#number of covariates (before the loci in the data.frame, do not change this!!)
```

Define population dynamics:

```{r}

#reproduction
para$n.offspring = 2

#migration
para$mig.rate <- 0.1 

#dispersal: exponential dispersal with maximal distance in map units
para$disp.max=50   #average  dispersal of an individual in meters
para$disp.rate = 0.05 #proportion of dispersing individuals

#Define genetics
para$n.allels <- 10
para$n.loci <- 20
para$mut.rate <- 0.001
```

Define cost distance method:

```{r}
para$method <- "leastcost" #rSPDdistance, commute
para$NN <- 8  #number of neighbours for the cost distance method

# Initialize simulation of populations from scratch

 landscape<- r  #<-raster(system.file("external/rlogo.grd", package="raster"))

# Define x and y locations

 para$locs <-createpops(n=para$n.pops, mindist = 3, 
                                      landscape = r, plot = TRUE)
 #give the population some names 
 rownames(para$locs) <- LETTERS[1:para$n.pops]
  
  
# Create a costdistance matrix 
 
  cost.mat <- PopGenReport::costdistances(landscape, para$locs, 
                                          para$method, para$NN) 
  #needed for the simulation
  eucl.mat <- as.matrix(dist(para$locs))  #needed for the analysis later

# Plot your landscape with the populations....
  
  plot(landscape)
  points(para$locs[,1], para$locs[,2], pch=16, cex=2, col="orange")
  text(para$locs[,1],para$locs[,2], row.names(para$locs), cex=1.5)
  
# Check the parameter list
  
  para

```

### b) Initialise your population on the landscape  

Now finally we can initialise our population using the init function

```{r}
simpops <- PopGenReport::init.popgensim(para$n.pops, para$n.ind, para$sex.ratio, 
                            para$n.loci, para$n.allels, para$locs, para$n.cov )  
```

You may want to check the simpops object, which is simply a list of our subpopulation and each individual is coded in a single run in one of the subpopulations.

```{r}
names(simpops)  #the names of the subpopulations
head(simpops$A) # a list of the first 6 individuals of population A
```

We can also analyse our simpop  object. (e.g. calculate the pairwise Fst value between all the populations).

To be able to do that we first need to convert it into a genind object (because many function need this type of object as input).

```{r}
gsp <- PopGenReport::pops2genind(simpops, locs =para$locs)
gsp #check the genind object
summary(gsp)  #some summary statistics
round(mmod::pairwise_Gst_Nei(gsp),3)
```

Is there an effect of the landscape on the population structure (there should not be after initialisation)?

The function 'pairwise.fstb' is around 150 times faster than mmod::pairwise_Gst_Nei, but slightly different.

```{r}
gen.mat <- PopGenReport::pairwise.fstb(gsp)  
round(gen.mat ,3)
```

Partial mantel test:

```{r}
PopGenReport::wassermann(eucl.mat = eucl.mat, cost.mats = list(cost=cost.mat), 
                           gen.mat = gen.mat, plot=F)$mantel.tab
```

Check the pairwise Fst values, why are they so low? 

Now we can run our simulation by simply passing our simpops, with some additional parameters that are needed for the simulation. The number of generation the simulation should run is in the steps parameter. (check ?run.popgensim for a description of all parameters).

Important to understand is the idea of the cost.mat (which is the cost matrix that is used for the distance between subpopulation). The n.alleles, n.ind cannot be different from the initialisation.

## 4. Run simulations and analyze results

### a) Run your population years steps on the landscape
  
```{r}
simpops <- PopGenReport::run.popgensim(simpops, steps=3, cost.mat, 
                         n.offspring=para$n.offspring, n.ind=para$n.ind,
                         para$mig.rate, para$disp.max, para$disp.rate, 
                         para$n.allels, para$mut.rate,
                         n.cov=para$n.cov, rec="none")
```

In essence we were running a metapopulation with 100 individuals per subpopulation on our resistance landscape for 3 generations. The question is now was that enough time to create an effect on population structure?

We should check now the pairwise Fst values and then do a landscape genetic analysis using partial mantel tests.

### b) Analyse your simulated population using an LGA (partial Mantel test)

NOTE HW: WHAT DOES LGA STAND FOR?

Convert to genind to calculate pairwise Fst.

```{r}
gsp <- PopGenReport::pops2genind(simpops, para$locs, para$n.cov)
```

Calculate your genetic distance matrix e.g. fst or D.

```{r}
gen.mat <- PopGenReport::pairwise.fstb(gsp)   
round(gen.mat ,3)
```

Partial mantel test with the function 'wassermann' (check help file: ?wassermann).

```{r}
PopGenReport::wassermann(eucl.mat = eucl.mat, cost.mats = list(cost=cost.mat), 
             gen.mat = gen.mat, plot=F)$mantel.tab
```

### c) PROPOSED: Alalyze your simulated populations using 'Sunder'

```{r}

```

## 5. Run simulations and analyze results

### a) Run for a longer time

Now rerun the simulation a further 20 steps and check again....

```{r}
simpops <- PopGenReport::run.popgensim(simpops, steps=20, cost.mat, 
                         n.offspring=para$n.offspring, n.ind=para$n.ind,
                         para$mig.rate, para$disp.max, para$disp.rate, 
                         para$n.allels, para$mut.rate,
                         n.cov=para$n.cov, rec="none")
```

Convert to genind to calculate pairwise Fst.

```{r}
gsp <- PopGenReport::pops2genind(simpops, para$locs, para$n.cov)
```

Calculate your genetic distance matrix e.g. fst or D.

```{r}
gen.mat <- PopGenReport::pairwise.fstb(gsp)    
round(gen.mat ,3)
```

Partial mantel test.

```{r}
PopGenReport::wassermann(eucl.mat = eucl.mat, cost.mats = list(cost=cost.mat), 
             gen.mat = gen.mat, plot=F)$mantel.tab
```

### b) Play with simulator to evaluate different scenarios

You can now "play" with the simulator using different landscape, number of subpopulations, different locations, number of alleles, number of loci etc. For example rerun your analysis for only 4 subpopulations. How does this affect your ability to detect an effect of the landscape?


## 6. Run simulator using a previously defined parameter set

Once the simulator works and you are certain that you understand how the simulator needs to be set up for a single run, in almost all studies on simulations you want to be able to re-run the simulator in an automatized way. There are several reasons why you want to do that.

1. You want to perform a sensitivity analysis on a single parameter, which means, try to find how much does the output (e.g. pairwise Fst between subpopulations) change when you vary an input parameter (e.g. number of loci). 
2. You want to explore the "complete" parameter space, which means, instead of changing  values of a single input parameter you want to change all parameters (within certain levels) and run their combinations. 
3. Another reason is that you want to create a simulated test data set that forms the backbone of your future studies.

So we would like to do the following. 

- a) Specify and record all the parameter combinations that you would like to run.  
- b) Run the simulator with every combination 
- c) [Optional] save your complete simulation run. ( recommended, but sometimes prohibitive due to needed resources) or only a calculated summary.
- d) Read in your simulations, analyse them and synthesize your results via additional statistics, tests, plots.
- e) Publish an enormously important paper....


Admittedly there are several different approaches and as it seems every modeller has a slightly different way to achieve the first four steps. One approach is basically to create a parameter file that records all the parameter setting for each run. Another approach is to create so called scripts for every single run. The advantage here is that scripts can be easily distributed across different cores and machines and therefore this approach is easy to parallelise your runs, which sometimes is necessary. Finally the approach I will present here (also because of pratical reason) is to create an R data.frame that stores all the parameter settings and we run all combinations in serial. 


Okay before we start we need to think about what kind of parameters we want to explore. I would like to do the following runs. Run our simulations as above (same parameter settings) for varying time steps (say between 5 to 105 years in steps of 20). As output I would still like to record the Fst value, but also the full genetic data set and the parameters used to run the simulation.


In addition I want to repeat each run say 5 times (most often you would do more repetitions) to check how much general variation there is between runs with exactly the same parameter combination. 

### a) Specify and record the parameter combinations


Let's us define the time steps we would like to run via:

```{r}
timesteps <- seq(from=5 , to=105, by=20)

```

And also the number of repeats via:

```{r}
repeats <- 1:5
```

Now we would like to have data.frame that store all possible combinations for those two parameters. As simple way to do that in R, is to use the ```expand.grid``` function.

```{r}
para.space <- expand.grid(rep=repeats, time=timesteps)
head(para.space)
#number of combinations
nrow(para.space)

```

As you can see this results in 30 combinations. The beauty of this approach is that it is very flexible and adaptable to runs over other parameter combinations.

Now to the next step...

### b) Run the simulator over every parameter combination.

Remember our parameter are all defined in the para object and we want to keep them, except running the simulation for different number of years.

In general a single run of our simulator runs via:

```{r, eval =F}

###No need to run this###
#initialize
simpops <- PopGenReport::init.popgensim(para$n.pops, para$n.ind, para$sex.ratio, 
                            para$n.loci, para$n.allels, para$locs, para$n.cov )  
#run for 20 generations
simpops <- PopGenReport::run.popgensim(simpops, steps=20, cost.mat, 
                         n.offspring=para$n.offspring, n.ind=para$n.ind,
                         para$mig.rate, para$disp.max, para$disp.rate, 
                         para$n.allels, para$mut.rate,
                         n.cov=para$n.cov, rec="none")



```


What is now left to be done is to write a loop around a single run and change the parameter values as needed. We do that here with a for-loop over the combinations in the para.space data.frame.

```{r, eval=F}

#again no need to run it
for (i in 1:nrow(para.space))
{
###No need to run this###
#initialize
simpops <- PopGenReport::init.popgensim(para$n.pops, para$n.ind, para$sex.ratio, 
                            para$n.loci, para$n.allels, para$locs, para$n.cov )  
#run for para.space$time[i] generations
simpops <- PopGenReport::run.popgensim(simpops, steps=para.space$time[i], cost.mat, 
                         n.offspring=para$n.offspring, n.ind=para$n.ind,
                         para$mig.rate, para$disp.max, para$disp.rate, 
                         para$n.allels, para$mut.rate,
                         n.cov=para$n.cov, rec="none")

}
```


Have a close look at the change. The only difference is now that we run the simulation nrow(para.space) (=30) times. This by itself is not really useful yet, because we need to store the simulation runs somehow, so we can collect them afterwards to calculate a summary statistics and analyse the runs. When we save the simluation in a file you may ask how do store the repeats seperately as they are not part of the parameter definition. One approach would be to have a different file name for every repeat, but a in my view cleaner approach is to store the all simulation outputs and also store the complete parameter and input information in a file, so everything that is need is in one place. A nice way to do that in R is to create a so called list object that stores all in a single object, which can be saved (and is automatically packed) as an R object.


### c) Save you complete simulation run (input and output)

First I create on my computer a subfolder named "simout" and set the working directory there. In this tutorial I set it to R_temp (to make sure the tutorials runs everywhere)

```{r, eval=F}
#somewhere sensible e.g.
outpath <- "D:/Bernd/DGS"

```





```{r}

#set directory to simout
#setwd(outpath)
#script needs to have a subfolder simout, if not there it will be created
if (!dir.exists("simout")) dir.create("simout")

#create a timer (just to know how long it will take roughly)

timer0 <- round(proc.time()[3],2)


for (i in 1:nrow(para.space))
{
###No need to run this###
#initialize
simpops <- PopGenReport::init.popgensim(para$n.pops, para$n.ind, para$sex.ratio, 
                            para$n.loci, para$n.allels, para$locs, para$n.cov )  
#run for para.space$time[i] generations
simpops <- PopGenReport::run.popgensim(simpops, steps=para.space$time[i], cost.mat, 
                         n.offspring=para$n.offspring, n.ind=para$n.ind,
                         para$mig.rate, para$disp.max, para$disp.rate, 
                         para$n.allels, para$mut.rate,
                         n.cov=para$n.cov, rec="none")
#convert to genind object (smaller)
gi <- PopGenReport::pops2genind(simpops)

#create a list of all I want to collect
sim <- list(para.space=para.space[i,], para=para, landscape=landscape, cost.mat=cost.mat, gi=gi )
#save everything in an output folder (with a consecutive number, with three leading zeros, so the file sorting is nicer)
save(sim, file = paste0("./simout/sim_time5-105_rep5_",sprintf("%03i",i) ,".rdata"))

cat(paste("Finished run:", i,"out of",nrow(para.space),".So far took:", round(proc.time()[3]-timer0,2),"sec.\n"))
flush.console()
}



```

### d) Analyze and synthesize results 

If you check your output folder (simout) you should see 30 files.

```{r}
head(dir("./simout"))
```

Now we are at step D where we need to read in all our files one by one. Calculate maybe some statistics and plot our data. Again this could be easy, but be aware if you have thousands of files it could take quite some time and memory. The most convinient way is to load everyting and store it in a list, so we can access all of our simulations from memory. I will show you how to do this in the example below, but be aware in larger simulations (think millions of runs) this is not possible and we would load a single simulation, calculate a statistic, store only the result in a table and free the memory for the next simulation run.

So now let us load our simulation runs. There is one caveat in the way we stored our data here. In R if you use the load command the simulation run appears as a list object with the name of 'sim' in our workspace (we saved it under that name). So once we load the second object the first is overwritten. So if we want to keep it we need to store it somewhere else.

```{r}


res <- data.frame(rep=NA, time=NA, fst=NA)
reslist <- list()
#load all files in the folder
filenames <- list.files(path="./simout", pattern="sim")

for (i in 1:length(filenames))
{
  #creates a sim object
  load(paste0("./simout/",filenames[i]))
  #now let us take what we need from the simulation
  
  res [i,1:2] <- sim$para.space
  gi <- sim$gi
  
  #calculate a summary statistic
  pfst <- mean(PopGenReport::pairwise.fstb(gi))
  res [i,3] <- pfst
  
  #now for convinience store everyting in a long list, 
  reslist[[i]]<- sim
}


```

You can look at the res data.frame and check the results. The next step would be to visualise the results (e.g. plot runs over times and color by rep).

A quick way to do that is to use ggplot. 

For example:

```{r}

ggplot2::ggplot(res, ggplot2::aes(x=time, y=fst, colour=factor(rep)))+ ggplot2::geom_point()
```

Now it is again time for you to experiment. For example, why not set up a simulation that varies the number of loci. Or as you may have seen even after 100 generation there was no sign that the mean pairwise Fst value is levelling off. So how long do you have to run a simulation in terms of time to see this (be aware takes longer)?

Have fun and please give us feed back what you think about this tutorial. [Bernd Gruber](mailto:bernd.gruber@canberra.edu.au), [Erin Landguth](erin.landguth@gmail.com), [Helene Wagner](mailto:helene.wagner@utoronto.ca).


```{r message=FALSE, warning=TRUE, include=FALSE}
LandGenCourse::detachAllPackages()
```
